# 문제

<pre>
LRU: Least Recently Used
가장 오랫동안 사용하지 않은 것을 제거하는 알고리즘
캐시의 크기가 주어지고, 캐시가 비어있는 상태에서 N개의 작업을 CPU가 차례로 처리한다면 
N개의 작업을 처리한 후 캐시 메모리의 상태를 가장 최근 사용된 작업부터 차례대로 출력
</pre>

# BEFORE

<pre>
작업 요소가 queue 안에 없으면 앞에서부터 추가,
있으면 해당 요소를 queue 맨 앞으로 가져오고 나머지 요소들을 한 칸씩 뒤로 미는 구조이다.
배열의 앞에서부터 작업 요소를 하나씩 추가하다가 새 작업 요소가 배열 안에 있는지 여부를 조사해서 
있으면 해당 배열의 요소를 삭제하고 맨 앞에 추가한다.
나머지 요소들이 한 칸씩 밀리는 부분은 splice로 요소를 삭제 후 추가해 넣으면 자동으로 해결될 것 같다.
추가해 넣을 때 배열의 길이가 입력값으로 들어온 배열의 길이를 초과하면 배열의 맨 뒤의 요소를 삭제한다.
</pre>

# AFTER

<pre>
답 코드가 2가지 버전이 있었는데
하나는 0으로 초기화된 배열을 만들고 배열의 알맞은 위치에 값을 넣어주는 방식이었고 
다른 하나는 내가 푼 방법과 유사하게 pop과 unshift를 사용했지만 내 풀이보다 훨씬 더 적은 변수를 사용하는 방법이었다. 

2번째 방법이 더 와닿아서 2번째 방법에서 얻은 힌트로 문제를 다시 풀어보고, 이후 1번째 방식으로도 풀어보았다.
1번째 방식의 경우, 반환할 배열에 값을 포함하고 있든 포함하고 있지 않든 무조건 맨 앞에 값을 추가했고(answer[0] = x) 
한 칸씩 미는 구간은 포함하고 있을 때는 배열 맨 끝까지, 포함하고 있지 않을 때는 index번째까지 돌면서 다음 값을 이전 값으로 대체했다.
</pre>
