# 문제

<pre>
N개의 숫자가 입력되면 오름차순으로 정렬하여 출력
</pre>

# BEFORE

<pre>
삽입 정렬은 배열의 2번째 요소(1번째 인덱스)에서 비교를 시작한다.
또한 '왼쪽'에 있는 모든 값(= 이미 정렬된 값)들과 비교하여
교환이 필요하면 그때그때 교환하고 다음(오른쪽)으로 넘어간다.
(=> 매 사이클마다 맨 끝까지 모든 비교를 하지 않는다)
그래서 버블 정렬 및 선택 정렬과 동일하게 O(N2)의 시간 복잡도를 갖고 있어도
삽입 정렬이 세 정렬 방식 중에 평균적으로 가장 빠르며
최고의 시나리오일 때는 유일하게 O(N)의 시간복잡도를 가진다.
</pre>

# AFTER

<pre>
문제를 풀면서 알게 된 것은 자바스크립트에서 인덱스가 -1번째인 값을 출력하면 배열에 없는('-1') 값인데도 아무 에러가 안 난다는 것이었다.
콘솔로 출력해봤지만 해당 콘솔 라인 자체가 출력되지 않았고 따로 에러가 발생하지도 않았다.
하지만 자바스크립트가 이렇게 스리슬쩍 넘어간다 해도,
의미상 출력하지 말아야 할 것은 출력하지 않는 게 좋을 것 같아사
원래 0부터 시작하던 답 코드의 i를 다시 풀 때는 1로 바꾸었다.
(=> 첫 j가 -1이 아닌 0부터 시작할 수 있도록)

또 알고 보니 내가 처음에 풀었던 코드는 답은 나왔지만 로직이 틀린 코드였다.
i번째 값을 뽑은 뒤 그걸 기준으로 왼쪽에서 뽑은 값(j)을 하나씩 비교해야 하는데
내 로직은 j번째 값끼리만 비교하고 있었다. (로직 자체가 틀렸는데 답이 나왔다 신기..)

1번째 답 코드에서는 tmp라는 변수를 선언하여 i번째 값을 저장하고
j를 i - 1부터 왼쪽으로 돌려서 i번째 값과 하나씩 비교했다. 
만약 j번째 값이 tmp(i번째 값)보다 크면 자리를 바꾸는데
이때의 방법이 앞의 문제풀이에서의 [[], []] 문법을 사용하지 않았다.
tmp가 j-for문 바깥에 살아있다는 점을 이용해서 j + 1번째를 j번째 값으로 덮어씌운 뒤 
살아있는 tmp(i번째 값)를 j+1번째에 넣어주었다.
(이때 주의할 점은 for문을 빠져 나올 때 for문의 증감식은 통과하고 
for문의 조건문에 걸려서 빠져 나온 것이기 때문에 j가 -1이 더 되어 있다는 점이다. 
따라서 tmp를 넣을 때 j번째가 아닌 j+1번째에 넣어줘야 한다)
또는 j번째 값이 tmp(i번째 값)보다 크지 않으면 바로 break로 for문을 빠져나오고
j+1번째에 tmp(arr[i])를 넣어주는 작업만 진행한다.

2번째 답 코드에서는 answer를 빈 배열로 선언하고
arr의 맨 첫 번째 값(arr[0])을 answer에 넣어준 채로 for문을 시작했다.
이미 배열 안에 값이 하나 있는 상태이기 때문에 i는 0이 아닌 1부터 시작하고,
j는 0부터 answer 배열의 길이까지 돌려주면 1번째 답 코드에서의 i까지 돌려주는 것이나 마찬가지가 된다.
또 2번째 버전에서는 j끼리 비교하는 대신 arr의 i번째 값과 answer 배열의 j번째 값을 비교헤주고 있었고,
splice 메서드를 통해 값 추가를 바로 진행해주었다. (1번째 버전보다 특정 자리에 값을 추가하는 과정이 좀 더 간단한 느낌이다)
</pre>
