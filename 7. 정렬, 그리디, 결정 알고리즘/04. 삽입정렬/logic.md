# 문제

<pre>
N개의 숫자가 입력되면 오름차순으로 정렬하여 출력
</pre>

# BEFORE

<pre>
삽입 정렬은 배열의 2번째 요소(1번째 인덱스)에서 비교를 시작하여
'왼쪽'에 있는 모든 값(= 이미 정렬된 값)들과 비교하여
교환이 필요하면 그때그때 교환하고 다음(오른쪽)으로 넘어간다.

삽입 정렬은 매 사이클마다 모든 비교를 하지 않아서
버블 정렬 및 선택 정렬과 동일한 시간복잡도(O(N2))를 갖고 있어도
세 정렬 방식 중에 평균적으로 가장 빠르며
최고의 시나리오일 때 유일하게 O(N)의 시간복잡도를 가져서 효율성이 우수하다.
</pre>

# AFTER

<pre>
문제를 풀면서 알게 된 것은 자바스크립트에서 인덱스가 -1번째인 값을 출력하면 배열에 없는('-1') 값인데도 아무 에러가 안 난다는 것이었다.
콘솔로 출력해봤지만 해당 콘솔 라인 자체가 출력되지 않았고 따로 에러가 발생하지도 않았다.
하지만 자바스크립트가 이렇게 스리슬쩍 넘어간다 해도, 의미상 출력하지 말아야 할 것은 출력하지 않는 게 좋을 것 같아서
원래 0부터 시작하던 답 코드의 i를 1로 바꾸었다. (=> 첫 j가 -1이 아닌 0부터 시작할 수 있도록)

알고 보니 내가 처음에 풀었던 코드는 답은 나왔지만 로직이 틀린 코드였다.
i번째 값을 뽑은 뒤 그걸 ㄴ기준으로 왼쪽에서 뽑은 값(j)을 하나씩 비교해야 하는데
내 로직대로 실행하면 j번째 값끼리만 비교했다. (로직 자체가 틀렸는데 답이 나오다니 신기..)

[1번째 풀이 순서]
1. answer를 arr로 초기화한다.
2. 1부터 arr의 길이까지 도는 for-i문을 선언한다.
3. 변수 tmp를 선언하고 arr의 i번째 값으로 초기화한 뒤 변수 j를 선언한다.
4. i - 1부터 0까지 감소하면서(--) 도는 for-j문을 선언한다.
5. 만약 j번째 값이 tmp(arr[i])보다 크다면 j + 1번째에 j번째 값을 넣고, 아니면 break로 for-j문을 탈출한다.
6. for-j문을 다 돌고난 후 j + 1번째 값에 tmp를 넣어준다.

[2번째 풀이 순서]
1. answer를 빈 배열로 초기화하고 arr의 0번째 값을 추가한다.
2. 1부터 arr의 길이까지 도는 for-i문을 선언한다.
3. 0부터 answer의 길이까지만 도는 for-j문을 선언한다.
4. arr의 i번째 값이 answer의 j번째 값보다 작은 경우가 있으면
  answer의 j번째에서 0개를 삭제하고(= 아무 것도 삭제하지 않고) arr의 i번째 값을 추가한다. 
=> 이렇게 하면 j번째 자리에 i번째 값이 들어가기 때문에 기존의 j번째 값이 뒤로 1칸 밀리게 된다. (즉, i번째 값 다음에 j번째 값 등장)
이렇게 추가를 하고 되면 해당 i번째의 answer에서의 작업은 끝나기 때문에 
break를 통해 answer를 돌던 j문을 빠져나와 arr의 다음 i번째 값을 진행한다.

2번째 방법은 주어진 arr에서 값을 하나씩 뽑아 answer에 있는 값들과 비교하면서 
조건에 해당하면 answer의 알맞은 자리에 i번째 값을 바로 추가하는 방식이다.
개인적으로 2번째 방법이 더 가독성 있고 사용하기 쉬운 것 같다.
</pre>
