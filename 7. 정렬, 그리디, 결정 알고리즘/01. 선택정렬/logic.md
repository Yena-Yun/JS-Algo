# 문제

<pre>
N개의 숫자가 입력되면 오름차순으로 정렬하여 출력
</pre>

# BEFORE

<pre>
선택 정렬은 임시 변수 하나를 선언하고 
배열의 각 요소를 변수 값과 비교하며 변수를 교체시키다가 
최종 결정된 변수 값을 배열의 맨 앞 자리부터 배치시키는 정렬 방식이다.
매번 교환이 발생하는 버블 정렬과 달리,
하나의 사이클에서 계속 비교 후에 비교가 끝나면 단 1번 교환이 발생한다.

[예상한 풀이 순서]
1. 이중 for문을 작성한다. (j-for문은 i+1번째부터 루프 시작)
2. i-for문 안에 target 변수를 선언하고 answer[i]로 초기화한다.
3. i-for문 안에 j-for문을 다 돌고난 뒤(= 배열의 각 요소와 target 변수와의 비교가 끝난 뒤) 
   위치를 바꿀 때를 대비하여 j번째 값의 위치를 저장할 previous 변수도 선언한다.
4. j-for문으로 target과 배열 요소들을 하나씩 비교하다가 target보다 작은 값을 발견하면 
   target 변수를 찾은 값으로 교체하고 previous 변수에 해당 값의 위치(= j 인덱스)를 저장한다.
5. j-for문을 다 돌고나서 분기에 따라 다음을 진행한다.
  1) target 값과 answer[i] 값이 여전히 같다면(= 원래부터 올바른 위치였다면) 
     다음 i-for문을 돌 수 있게 조건식으로 바로 점프(=> continue)한다.
  2) 그 외의 경우에는 target 값을 배열 앞에 위치시키기 위해 tmp 변수를 선언하여 이 두 값을 교환한다.
</pre>

# AFTER

<pre>
문제는 풀었는데 선언한 변수명(target, previous)과 전체적인 코드(continue 사용 등)가 맘에 들지 않았다.
답 코드를 살짝 보니 index만 사용하고 있어서 그걸 힌트 삼아서 다시 풀었더니 코드가 훨씬 간결해졌다. 
값은 비교할 때만 필요하고 실제 자리를 바꾸기 위해선 '위치'만 필요하기 때문에 index만 저장해두어도 상관이 없었던 것이다.
자바스크립트의 [[], []] 문법을 알게 된 것도 좋았다. 따로 변수를 선언할 필요 없이 값 교환이 너무 간편했다.

[풀이 순서]
1. 0에서 arr의 길이까지 도는 for-i문을 선언한다.
2. 변수 idx를 선언하고 매 회차마다 i를 기록한다.
3. i+1부터 arr의 길이까지 도는 for-j문을 선언한다.
4. j번째 값이 idx(i)번째 값보다 작으면 변수 idx를 해당 번째 j로 교체한다.
5. for-j문을 다 돌고 나서 i번째 값과 idx번째 값을 [[], []] 문법을 이용하여 교체한다.
</pre>
