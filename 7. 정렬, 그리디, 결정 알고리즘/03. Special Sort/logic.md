# 문제

<pre>
N개의 입력된 정수 값을 정렬해야 한다. 
음의 정수는 앞쪽에, 양의 정수는 뒷쪽에 있어야 하며
양의 정수와 음의 정수 각각의 순서에는 변함이 없어야 한다.
</pre>

# BEFORE

<pre>
음수, 양수 각각의 경우에 순서는 바뀌지 않고
음수가 양수보다 먼저 와야 하므로 음수만 찾아서 앞쪽에 순서가 변하지 않게 정렬해야 한다.
(음수를 앞으로 빼면 양수는 저절로 정렬됨) 

중첩 for문을 돌아서 i는 음수를 찾는 데 쓰고 j는 찾은 음수를 넣을 자리를 표시한다.
(예: 1번째로 찾은 음수 -3을 j(0)번째에 넣은 후 j를 옆으로 1칸 옮긴다 (j = 1).
그 다음 찾은 음수 -2를 1칸 옮긴 j 자리(1번째 인덱스)에 넣는다. => 반복)

순서가 '숫자의 크기'로 정해지는 것이 아니어서 
값이 아닌 단순 '위치(인덱스)'를 비교해야 한다.
</pre>

# AFTER

<pre>
음수를 찾아서 idx번째에 넣었더니 원래 idx 자리에 있던 값을 대체해버려서
고민 끝에 queue 자료구조를 사용해보기로 했다.

그러면 뒤에서부터 앞으로 가면서 음수를 찾아
splice로 꺼낸 다음 unshift로 앞에서부터 추가해주면 될 것 같았는데
실제 해보니 -6, -2는 잘 배치했지만 -3을 잡아내지 못했다.
콘솔을 찍어보니 unshift 메서드 때문에 인덱스가 1칸씩 밀리고 있었다.

queue 배열을 선언해서 음수만 골라넣은 뒤
나중에 양수만 남은 arr 배열 앞에 추가해주는 방법을 사용했다.
답은 구했지만 내가 짠 코드는 약간 어거지로 짠 것 같은 느낌이 강했다.

답 코드에서는 2가지 방법을 사용했다.

[1번째 방법: 버블 정렬]
1. 0부터 len(arr의 길이) - 1까지 도는 for-i문을 선언한다.
2. 0부터 len - i - 1까지 도는 for-j문을 선언한다. 
<s>3. j번째 값이 j+1번째 값보다 크다면 [[], []] 문법을 이용하여 두 값을 교환한다. (원래 버블 정렬에서의 교환법)</s>
3. j번째 값이 0보다 크고 j+1번째 값이 0보다 작으면 [[], []] 문법을 이용하여 두 값을 교환한다.
(=> 한쪽이 양수이고 다른 한쪽은 음수이면 && 음수가 양수보다 오른쪽에 있으면 교환한다)

즉, 비교하는 값이 둘 다 양수 또는 음수이거나
음수가 양수의 왼쪽에(올바른 자리에) 있으면 값을 교환하지 않는다.

이렇게 버블 정렬을 하고 나면 
양수와 음수 각각의 순서는 바뀌지 않으면서
음수는 전부 왼쪽에, 양수는 전부 오른쪽에 몰아서 배치할 수 있다.

[2번째 방법: 빈 배열에 단순 push하기]
1. answer를 빈 배열로 초기화한다.
2. arr를 돌면서 음수인(0보다 작은) 것을 먼저 뽑아 answer에 추가한다.
3. 다음에 양수인(0보다 큰) 것을 뽑아 answer에 추가한다.

이중 for문을 돌지 않으면서 버블 정렬보다 훨씬 간단한 로직의 방식이다.
실제 구현할 일이 생기면 가독성도 좋고 시간복잡도도 더 나은 2번째 방법을 써야겠다.
</pre>
