# 문제

<pre>
N개의 수를 오름차순으로 정렬한 다음 N개의 수 중 
한 개의 수인 M이 주어지면 
이분검색으로 M이 정렬된 상태에서 몇 번째에 있는지 구하기
</pre>

# BEFORE

<pre>
예전에 공부했던 이분검색의 개념을 더듬거리며 떠올려가며 풀었다.
lt와 rt를 사용하고, target을 기준으로 mid를 옮겨가며 범위를 줄이면서
푸는 것까지는 기억이 났는데 이상하게 답이 똑 떨어지지는 않았다.
</pre>

# AFTER

<pre>
mid보다 target이 더 클 때의 답은 잘 나왔지만
mid보다 target이 더 작을 때의 답이 묘하게 어긋났다.
답 코드처럼 while로만 풀면 묘한 시점(?)의 차이가 해결될 것 같았는데
막상 풀어보니 mid의 설정 내용과 반복문 사용이 잘못된 것 같았다.

나는 mid를 arr.length / 2로 초기화하고 
mid를 반복문의 바깥에 선언한 반면 답 코드는 mid를 (lt + rt) / 2로 초기화하고 
mid를 반복문의 바깥이 아닌 안쪽에 선언했다.
또한 rt와 lt를 교체할 때도 나는 mid만 그대로 넣어주었는데
답 코드에서는 1을 빼거나 더해서 넣어주었다.

rt의 경우는 범위를 mid의 왼쪽으로 줄여야 하는데
if 조건문을 통해 mid는 이미 비교를 했기 때문에 
mid의 바로 앞까지인 mid - 1로 rt를 교체해주고,
lt의 경우는 반대로 mid의 바로 뒤인 mid + 1로 교체해주는 듯 했다.

mid는 매 범위가 바뀔 때마다 lt와 rt의 중간값으로 잡혀야 하기 때문에 
반복문의 안쪽 최상단에 선언해주고,
Math.floor 대신 parseInt를 쓸 수 있다는 것도 배웠다.

반복문은 lt가 rt보다 커지거나 같아지면(= target를 가리키는 mid를 찾으면) 종료하고
만약 반복문 내의 조건문에서 mid와 target이 같다는 것을 발견했다면
answer에 답(mid + 1)을 넣어주고 'break'로 반복문을 빠져 나온다.
(break: while의 조건문에 일치하지 않아도 내부 조건을 만족하여 강제로 반복문을 탈출함)
</pre>
