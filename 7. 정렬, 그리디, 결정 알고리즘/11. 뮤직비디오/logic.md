# 문제

<pre>
M개의 DVD에 모든 동영상을 녹화한다.
라이브에서의 순서가 그대로 유지되고, DVD의 크기(녹화 가능한 길이)를 최소로 하며, 모두 같은 크기에 녹화한다.
DVD의 최소 용량 크기 출력하기 (결정 알고리즘)
</pre>

# BEFORE

<pre>
결정 알고리즘은 이분 검색을 기반으로 하는 알고리즘이다.
배열을 정렬(sort)하고(이 문제에서는 배열이 미리 정렬되어 있어서 sort 과정이 빠졌다)
lt와 rt와 mid를 구해서 while(lt <= rt)를 사용하는 부분은 이분 검색과 동일하다.
이 문제는 결정 알고리즘의 대표적인 문제이다. 
('겹치지 않는 숫자 리스트를 N개의 그룹으로 나눌 때 한 그룹 당 최소의 숫자합을 구하라')

우선은 각 DVD마다 배열의 요소 하나는 무조건 포함해야 한다.
즉, 구하는 최소 용적이 적어도 배열의 '최대값'은 되어야 한다.
따라서 lt를 배열의 '최대값(Math.max)'으로 초기화한다.

rt는 DVD가 가질 수 있는 가장 큰 용적이다.
문제에서 따로 제한 사항이 없기 때문에(예: 'DVD마다 무조건 곡 1개는 꼭 들어가야 한다')
비어 있는 DVD도 있을 수 있으므로 DVD 하나에 가능한 가장 큰 용적은 배열의 '전체 합'이다.
(물론 이걸 바로 답으로 쓸 순 없다. 내가 구하는 건 주어진 곡 배열과 DVD 갯수를 가지고 가능한 DVD 하나의 '최소 용적'이기 때문이다)

이제 이분 검색을 하면서 target인 m(DVD의 갯수)을 넘지 않게 하면서 각 DVD가 최소인 경우의 용적을 구하면 된다.
이 과정에서 m과 비교하기 전 연산이 한번 더 필요하기 때문에 count라는 함수를 따로 선언해서 m과 비교할 DVD 갯수 cnt를 구한다.
count 함수에는 곡 배열(songs)과 탐색에 활용할 lt와 rt의 중간값(이분 검색을 사용하기 위해 대략적으로 잡은 중간 용적값, mid)가 전달된다.

[ count 함수 ]
필요할 DVD 갯수인 cnt와 곡 배열 반복문의 각 차례에서 총합인 sum을 선언한다.
문맥상 처음에 DVD에 곡을 넣어가며 확인하기 때문에 최소 DVD 1장부터 시작하게 되어 cnt의 초기값은 1이다. 
sum은 mid로 들어온 용적(capacity)을 넘어가는지 확인하기 위한 곡의 총합이므로 처음 초기값은 0이다.

songs 배열을 돌면서 songs에서 차례로 꺼낸 곡(x)을 sum에 더하면서 인자로 전달된 용적(capacity)을 넘어가는지 확인한다.
sum + x가 capacity를 넘어가지 않으면(=> 비교 먼저), sum에 x를 누적해서 더한다.

만약 sum + x가 capacity보다 더 크면(넘어가면) DVD 갯수(cnt)가 한 장 더 추가되어 cnt에 1을 더하고,
sum은 x로 '초기화'한다. (=> 해당 곡 x부터 그 다음 곡들을 더하면서 확인할 것이므로)

이렇게 해서 구해진 최종 DVD 갯수인 cnt를 반환한다.

[ solution 함수 ]
다시 원래 함수로 돌아와서, count 함수에서 반환된 cnt를 주어진 DVD 갯수인 m과 비교한다.
만약 cnt가 m보다 더 크면 DVD 하나 당 용적을 너무 작게 해서 DVD 갯수가 많아져버린 상황이므로
용적을 더 큰 범위에서 찾기 위해 용적을 구하는 최소 범위를 mid 윗쪽으로 올린다. (= lt를 mid + 1로 잡아서 더 큰 범위 내에서 찾게 한다)
반대로 cnt가 m보다 작거나 같으면 '주어진 DVD 갯수를 넘어가지 않고서 가능한 DVD의 용적'을 구한 것이기 때문에 answer를 mid로 교체해주고 
rt는 mid - 1을 하여 가능한 용적을 구하는 범위를 mid 아래쪽으로 잡아준다.
이 과정을 반복하다 보면 최소값인 mid(capacity)가 구해진다.
</pre>

# AFTER

<pre>
이 문제는 결정 알고리즘 코드를 검색해서 찾아봤는데도 이해가 잘 안 되어서
찾은 코드를 따라 치고 BEFORE에 주석 달듯 코드를 한줄 한줄 해석하면서 겨우 이해할 수 있었다.
마지막 부분에 count 함수가 m보다 '같은' 경우 왜 답을 바로 내지 않는지가 계속 이해가 안 됐는데
이건 AFTER를 작성하면서 알게 됐다. target 갯수인 m과는 일치를 했더라도 '최소값'인 용적을 구하려면
이분 검색으로 계속해서 범위를 더 줄여나가면서 마지막 '최종'값인 mid 단 하나를 구해야 하기 때문이었다.
rt가 점점 작아져서 lt보다도 작아져버렸을 때 while문을 탈출하게 되고, 그때 반환되는 mid가 바로 answer가 되는 것이었다.

어려운 문제였다. 익숙해지면 나아지겠지 ^-ㅠ 
</pre>
