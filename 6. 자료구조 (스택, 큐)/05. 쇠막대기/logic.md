# 문제

<pre>
쇠막대기와 레이저의 배치를 나타내는 괄호 표현이 주어졌을 때 
잘려진 쇠막대기 조각의 총 개수 출력
</pre>

# BEFORE

<pre>
'()' 모양이 되는 순간 레이저가 쏘아진다고 가정한다.
그리고 올바른 괄호가 되기 전(= 왼쪽 괄호만 나올 때) 새로운 막대기를 등장시켜 쌓아올린다.
쌓아올리는 막대기 갯수는 따로 카운트하다가
레이저('()')가 등장하는 순간 이 막대기들을 '자른다'(= 최종 잘려진 갯수에 추가한다)

이때 추가되는 갯수는 한 번 레이저를 쏠 때마다 
그 때까지 쌓아올렸던 막대기의 갯수만큼 올라간다. 
(예: 현재 막대기가 3개 쌓였다면 레이지를 쏠 때마다 잘려지는 갯수가 3개씩 추가됨)

오른쪽 괄호가 나오면 하나의 막대기의 '끝'이 등장하여 하나의 막대기가 끝난 것이므로 
잘려진 막대기 갯수에 1을 추가한다.
그리고 왼쪽 괄호가 다시 등장하면 쌓아올리는 갯수 쪽에 카운트를 올린다.
</pre>

# AFTER

<pre>
'()' 여부를 구하기 위해 뽑는 데에 '순서'가 필요하다고 생각해서 for-of문 대신 for-i문을 사용했다.
뽑은 것이 오른쪽 괄호일 때는 바로 이전 요소가 왼쪽 괄호였는지 여부로 실행문 로직을 다르게 하고
오른쪽 괄호가 아닐 때는 계속 stack에 추가해주었다.

-------------------------------------------------------------------
답 코드가 훨씬 간결해서 내가 푼 로직과 비교하며 분석해보았다.

나는 오른쪽 괄호에 중점을 둔 반면 답 코드는 왼쪽 괄호 여부를 먼저 판단했다. 
(왼쪽 괄호는 'stack에 추가'하는 로직밖에 없기 때문에 로직이 더 간단하다)

오른쪽 괄호에 중점을 둔 로직은 다음과 같다.
1) 우선 stack에서 1개를 제거한다.
(레이저이든 막대기의 끝이든 stack에서 무조건 하나는 삭제되어야 한다)
2) 바로 앞이 왼쪽 괄호였다면 레이저를 쏜 것이다. => answer에 stack의 길이만큼 더해준다.
3) 바로 앞이 왼쪽 괄호가 아니었다면(else) 막대기의 끝이다. => answer에 1을 더해준다. 
</pre>
