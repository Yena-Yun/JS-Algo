# 문제

<pre>
대문자 문자열을 입력받아 같은 문자가 연속으로 반복되는 경우 
반복되는 문자 바로 오른쪽에 반복 횟수를 표기
(반복 횟수가 1인 경우는 횟수 표기 생략)
</pre>

# BEFORE

<pre>
answer와 target 변수를 매개변수로 들어온 s의 1번째 문자로 초기화한다.
cnt는 0으로 초기화해둔다.
문자열을 돌면서 target과 다른 문자가 등장할 때까지 cnt에 1을 더한다.
이후 다른 문자가 등장하면 다음을 진행한다.
* cnt가 1일 경우 cnt를 빈 문자열로 만든다.
* 여태까지 구한 cnt를 answer에 추가한다.
* 이번에는 cnt를 1로 초기화한다. (처음을 제외하고는 cnt를 1로 초기화)
* target을 새로이 등장한 문자로 바꾼다.
* answer에 새로이 등장한 문자를 추가한다.
이 과정을 반복하면 될 것이다.
</pre>

# AFTER

<pre>
로직이 꽤 간단하다고 생각했는데 막상 풀어보니 답을 쉽게 구하기 힘든 문제였다. 
계속 한 두 글자가 답이 다르게 나와서 직접 문자열을 돌면서 
주석으로 answer, target, cnt 값을 변경시키며 손코딩을 했다.
손노동으로 얻은 로직에 따라 if문 안의 실행문의 순서를 미세하게 조정하다보니
어느 새 답이 구해지긴 했는데 뭔가 코드가 깔끔하지 못하다는 생각이 들었다.

답 코드를 보니 다음과 같은 점에서 차이가 있었다.
1) 나는 for-of문으로 푼 반면, 답 코드에서는 i-for문으로 풀고 그 안의 i를 이용했다.
2) 나는 비교할 기준 문자로 target이라는 변수를 설정했지만 답 코드에서는 i-for문의 i를 이용하여 단순히 그 다음 값(i + 1)과 현재 값(i)을 비교했다.
3) 나는 cnt === 1 일때 cnt를 빈 문자열('')로 설정하여 answer에 추가로 더해지지 않게 하는 방법을 썼지만
답 코드는 cnt가 1보다 클 때만 answer에 더해준다는 조건을 사용했다. (괜찮은 방법이었던 게, 어차피 문제의 특성 상 문자의 갯수가 0이 나올 수는 없어서 0과 1은 cnt에 설정될 수 없는 값이었다)
4) 나는 1번째 cnt를 0으로 설정하고(target과 answer를 s[0]로 초기화한 탓에..) 이후 for문을 돈 뒤에는 1로 초기화하는 방법을 썼는데,
 답 코드는 아예 처음부터 1로 초기화해두고 이후에도 1로 초기화해두어서 가독성 측면에서도 더 좋았고, 
 3)에서 말한 것처럼 문자가 0개인 경우가 아예 존재하지 않기 때문에 논리적으로도 처음부터 1로 초기화하는 게 맞았다.

 단, 답 코드에서 굳이 s에 공백 1칸(' ')을 더한 뒤
 s.length - 1을 쓰고 있다는 생각이 들었다.
 공백 1칸을 더하는 코드 줄을 삭제하고 for문의 s.length - 1를 s.length로 바꾸어도
 답에는 영향이 없어서 그렇게 코드를 수정했다.

 ** 앞으로 그 다음 값과 비교하는 문제는 for-of문 대신 i-for문을 사용해야겠다는 생각이 들었다.
</pre>
