# 문제

<pre>
** 챕터 3부터는 문제 간결화해서 올립니다.

회문 문자열: 앞에서 읽을 때나 뒤에서 읽을 때나 같은 문자열 ~(이효리)~
입력된 문자열이 회문이면 "YES", 아니면 “NO" 출력
(대소문자 구분 x)
</pre>

# BEFORE

<pre>
가장 단순히 생각하기에는 reverse 메서드가 떠올랐다.
자바스크립트에서 문자열은 iterable이니까
문자열에 reverse를 붙여 뒤집고 바로 받은 문자열과 비교하면 될 것이다.

=> 대소문자 구분을 없애기 위해 받은 문자열에 .toLowerCase()를 붙이는 순간부터 
자동완성이 안 되어서 직감했지만 답이 안 나왔다. 
그러면 split으로 실제 배열에 담은 다음에 reverse를 써서 뒤집고 
join으로 다시 문자열로 만든 다음 .toLowerCase를 써서 위에처럼 비교해보자 생각했다.

=> 문제는 풀렸지만 if문의 조건문이 꽤 길어졌다.
코드는 충분히 짧은데 한눈에 보기에도 '가독성'이 좋아보이진 않았다. 
클린 코드란 무조건 짧은 코드가 아니라, 내가 아닌 다른 사람이(또는 며칠 뒤의 내가) 
한 번에 알아보기 쉬운 코드라는 말이 떠올랐다.
if문의 조건문을 좀 더 풀어쓰기 위해 for문을 사용한 코드를 작성해보았다.

for문으로 문자열에서 문자를 하나씩 꺼낸 뒤 소문자로 만들어서 새 배열에 넣고 
새 배열을 뒤집고 join으로 묶어서 들어온 문자열의 소문자 형태와 비교했다.

비교하는 과정에서 처음에는 if-else문을 썼다가 
answer를 애초에 YES, NO 둘 중 하나로 초기화 해놓으면
else를 안 써도 될 것 같아서 그렇게 바꿨다.

for문을 사용해서 다시 문제를 풀긴 했지만 첫번째 방법과 메서드가 똑같아서인지(split을 for문으로 바꿈) 그다지 새로운 방식으로 풀었다는 느낌이 안 들었다.
답 코드는 어떻게 풀었는지 궁금해서 확인해보았다.
</pre>

# AFTER

<pre>
답 코드에서는 문제에서 준 '회문문자열'이라는 조건을 십분 활용하고 있었다.
1. 문자열을 '절반' 위치를 기준으로 앞뒤로 비교하고 
2. 문자열 길이가 홀수일 때를 고려하기 위해 for문에서 절반까지 돌기 위한 
배열 길이 설정에 Math.floor를 썼다.
3. answer를 미리 YES로 초기화해놓고 if문의 조건에 걸리면 바로 NO를 반환하고 
아니면 YES가 들어있는 answer를 반환하는 식으로 처리했다.
(answer = 'NO'라고 굳이 한번 더 연산을 해주지 않음)
이 짧은 답 코드에서 3가지나 배웠다. 
</pre>
