# 문제

<pre>
문자열 s와 문자 t가 주어지면 
문자열 s의 '각 문자'가 문자 t와 떨어진 '최소거리'를 출력
</pre>

# BEFORE

<pre>
문제를 보자마자 어떻게 풀어야할지 감이 전혀 안 오는 문제가 
봉우리 문제 다음으로 2번째로 등장했다. ㅎㅎ
하지만 종이에 입력값을 적고 이리저리 경우의 수를 나눠보니
(코드는 조금 어지러워질 것 같으나) 아주 못 풀 문제는 아니라는 생각이 들었다.

우선은 다음처럼 입력으로 들어온 문자열("teachermode")을 분석해보았다.

1 0 1 2 1 0 1 2 2 1 0
t e a c h e r m o d e
0 1 2 3 4 5 6 7 8 9 10

최소거리를 구하는 기준이 되는 문자는 'e'이다.
문자열을 기준으로 위쪽은 예상 답안(각 문자의 e로부터의 최소 거리),
아래는 앞에서부터 차례로 증가하는 각 문자의 본래 index 값이다.

예상 답안을 보니 마치 숫자로 이루어진 회문문자열의 모음같다고 생각했다.
(이전 문제들에서 회문문자열이 등장했던 이유는 바로 이 문제를 풀기 위한 빌드업이었지 않을까)
근데 회문문자열을 따지려면 맨 앞의 값과 맨 뒤의 값이 같은 지부터 먼저 비교해서 
점차 가운데쪽(?)으로 들어가며 비교해야 한다.
그러니 앞뒤에 서로 비교할 e가 없는 맨 처음 e와 맨 마지막 e는
회문문자열로 풀기 힘들거란 생각이 들었다. 
그래서 이 둘을 먼저 if문의 1번째, 2번째 조건문으로 잡고
그 외의 모든 경우, 즉 앞뒤에 e가 있고 그 사이에서 각 e와의 최소거리가
얼마나 되는지를 따지는 문제가 될 것 같다.

이러한 3가지 경우를 나누어 if문의 조건문 및 예상 실행문을 정리해보았다.

(그 이전에 가장 먼저 입력된 문자열 내에 기준이 되는 문자(e)들이 각각 몇 번째 인덱스에 있는지부터 파악한다)

조건문1) 첫 번째 e를 만나기 전
첫 번째 e가 있는 인덱스의 값(예: 5번째에 있다면 5)부터 1씩 감소하는 값을 차례로 각 문자에 부여 
(예를 들어 주어진 입력 문자열에서 첫 번째 e의 인덱스는 1이므로 앞에 있는 t의 (e와의) 최소거리는 1이 된다)
(만약에 첫 번째 e가 5번째 인덱스에서 등장했다면, 맨 앞에서부터 첫 번째 e가 등장할 때까지 5, 4, 3,.. 순서로 최소거리가 부여될 것이다)

조건문2) 마지막 e부터 문자열 끝까지
마지막 e는 맨 처음 e보다 쉽다. 그냥 마지막 e의 최소거리(0)부터 그 다음 문자들에 
1씩 증가한 값을 차례로 최소거리로 부여하면 된다.

조건문3) 앞 뒤에 e가 있는 경우들 (else)
위의 조건문 두 경우를 제외하면 나머지는 최소거리를 따지는 문자열의 범위의 양 끝단에 e가 있는 경우이다.
이제는 회문문자열 문제 풀었을 때처럼 판단하면 될 것 같다.

실제 연습장에 손노동으로 분석해보니 
첫 번째 e가 '1'번째, 두 번째 e가 '5'번째에 있다면
첫 번째 e부터 최소거리가 점차 증가하다가 이후 절반 지점에 다다르면 
(두 번째 e가 나타날 때까지) 최소거리가 감소한다.
따라서 Math.floor((5 - 1) / 2) 이런 식으로 연산한 뒤 
연산한 결과(= 절반 거리)가 될 때까지는 최소거리가 1씩 증가하다가 
절반 거리가 되면 그 이후는 1씩 감소하는 식으로 답을 구한다.

이 때 예외처리가 필요한데, 두 e 사이의 거리(뒤의 e 인덱스 - 앞의 e 인덱스)가 
'짝수'가 아닌 '홀수'이면 가운데 절반 부분이 두 번 등장한다.
(예: 0 1 2 2 1 0 에서 가운데 2가 두 번 나오고 이후 1씩 줄어듦)
이거는 바로 위의 숫자들을 배열로 봤을 때 배열의 길이가 총 6이니까
배열 길이 / 2 한 값 & (배열길이 / 2) - 1 한 값 이렇게 따져주면 될 것 같다.
</pre>

# AFTER

<pre>

</pre>
