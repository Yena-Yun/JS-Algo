# 문제

<pre>
문자열 s와 문자 t가 주어지면 
문자열 s의 '각 문자'가 문자 t와 떨어진 '최소거리'를 출력
</pre>

# BEFORE

<pre>
문제를 보자마자 어떻게 풀어야할지 감이 전혀 안 오는 문제가 
봉우리 문제 다음으로 2번째로 등장했다. ㅎㅎ
하지만 종이에 입력값을 적고 이리저리 경우의 수를 나눠보니
(코드는 조금 어지러워질 것 같으나) 아주 못 풀 문제는 아니라는 생각이 들었다.

우선은 다음처럼 입력으로 들어온 문자열("teachermode")을 분석해보았다.

1 0 1 2 1 0 1 2 2 1 0
t e a c h e r m o d e
0 1 2 3 4 5 6 7 8 9 10

최소거리를 구하는 기준이 되는 문자는 'e'이다.
문자열을 기준으로 위쪽은 예상 답안(각 문자의 e로부터의 최소 거리),
아래는 앞에서부터 차례로 증가하는 각 문자의 본래 index 값이다.

출력값을 보니 마치 숫자로 이루어진 회문문자열의 모음같다고 생각했다.
(이전 문제들에서 회문문자열이 등장했던 이유는 바로 이 문제를 풀기 위한 빌드업이었지 않을까)
근데 회문문자열을 따지려면 맨 앞의 값과 맨 뒤의 값이 같은 지부터 먼저 비교해서 
점차 가운데쪽(?)으로 들어가며 비교해야 한다.
그러니 앞뒤에 서로 비교할 e가 없는 맨 처음 e와 맨 마지막 e는
회문문자열로 풀기 힘들거란 생각이 들었다. 
그래서 이 둘을 먼저 if문의 1번째, 2번째 조건문으로 잡고
그 외의 모든 경우, 즉 앞뒤에 e가 있고 그 사이에서 각 e와의 최소거리가
얼마나 되는지를 따지는 문제가 될 것 같다.

이러한 3가지 경우를 나누어 if문의 조건문 및 예상 실행문을 정리해보았다.

(그 이전에 가장 먼저 입력된 문자열 내에 기준이 되는 문자(e)들이 각각 몇 번째 인덱스에 있는지부터 파악한다)

조건문1) 첫 번째 e를 만나기 전
첫 번째 e가 있는 인덱스의 값(예: 5번째에 있다면 5)부터 1씩 감소하는 값을 차례로 각 문자에 부여 
(예를 들어 주어진 입력 문자열에서 첫 번째 e의 인덱스는 1이므로 앞에 있는 t의 (e와의) 최소거리는 1이 된다)
(만약에 첫 번째 e가 5번째 인덱스에서 등장했다면, 맨 앞에서부터 첫 번째 e가 등장할 때까지 5, 4, 3,.. 순서로 최소거리가 부여될 것이다)

조건문2) 마지막 e부터 문자열 끝까지
마지막 e는 맨 처음 e보다 쉽다. 그냥 마지막 e의 최소거리(0)부터 그 다음 문자들에 
1씩 증가한 값을 차례로 최소거리로 부여하면 된다.

조건문3) 앞 뒤에 e가 있는 경우들 (else)
위의 조건문 두 경우를 제외하면 나머지는 최소거리를 따지는 문자열의 범위의 양 끝단에 e가 있는 경우이다.
이제는 회문문자열 문제 풀었을 때처럼 판단하면 될 것 같다.

실제 연습장에 손노동으로 분석해보니 
첫 번째 e가 '1'번째, 두 번째 e가 '5'번째에 있다면
첫 번째 e부터 최소거리가 점차 증가하다가 이후 절반 지점에 다다르면 
(두 번째 e가 나타날 때까지) 최소거리가 감소한다.
따라서 Math.floor((5 - 1) / 2) 이런 식으로 연산한 뒤 
연산한 결과(= 절반 거리)가 될 때까지는 최소거리가 1씩 증가하다가 
절반 거리가 되면 그 이후는 1씩 감소하는 식으로 답을 구한다.

이 때 예외처리가 필요한데, 두 e 사이의 거리(뒤의 e 인덱스 - 앞의 e 인덱스)가 
'짝수'가 아닌 '홀수'이면 가운데 절반 부분이 두 번 등장한다.
(예: 0 1 2 2 1 0 에서 가운데 2가 두 번 나오고 이후 1씩 줄어듦)
이거는 바로 위의 숫자들을 배열로 봤을 때 배열의 길이가 총 6이니까
배열 길이 / 2 한 값 & (배열길이 / 2) - 1 한 값 이렇게 따져주면 될 것 같다.

</pre>

# AFTER

<pre>
위의 로직으로 막상 코드를 작성해보니 너무 복잡한 로직이 나왔고 점점 하드코딩에 가까운 코드를 짜보아도 답이 나오지 않아서 고민하다가 답 코드를 확인했다.

우선은 답 코드를 대충 훑어보니 1000이란 값을 가지고 s의 길이만큼 한 번 끝까지 돌면서 증가하는 값을 더해준 뒤 다시 뒤에서부터 되돌아가면서 특정 조건에 해당할 경우 값을 빼주는 방식이었다.

그냥 봐서는 왜 1000이란 값을 사용하는지, 마지막의 Math.min 부분이 이해가 잘 안 되어서 코드를 치면서 콘솔을 찍어보며 분석해보았다.

우선 1번째 메인 로직은 p라는 변수를 임의로 1000이란 값으로 초기화해두고, p에 1씩 더하면서 answer에 추가하다가
t와 동일한 문자를 만나면 p를 0으로 초기화한다.
이 과정에서 한 번 t가 등장하고 나면 이후로는 1001, 1002, ... 가 아닌 1, 2, ... 처럼 1자리 숫자가 찍힌다.

이렇게 한 번 전체 문자열을 돌고 나면 
2번째 메인 로직에서는 p를 다시 1000으로 초기화하고
이번에는 뒤에서부터 돈다. (문자열의 맨 마지막부터 맨 앞까지)

이 과정에서 또 t와 같은 문자가 있으면 p를 0으로 초기화한다.
그리고 그 외의 과정에는 p에 1을 더해주는데, 
이때 p를 바로 answer에 추가하는 게 아니라 
기존에 있던 answer의 i번째 값과 p 중 더 작은 값(Math.min)으로 
answer[i]의 값을 교체한다. (여기가 키포인트..!)

종이에 손노동을 해보니 Math.min을 쓴 이유가 더 확실해졌다.

[ 1번째 for문 - 앞에서부터 뒤로 ]
p = 1000 (초기화)
  ---------------------------------------->
  t   e   a   c   h   e   r   m   o   d   e
1001  0   1   2   3   0   1   2   3   4   0

answer에 위의 숫자 배열을 넣는다.

[ 2번째 for문 - 뒤에서부터 앞으로 ]
p = 1000 (다시 초기화)
  <----------------------------------------
  t   e   a   c   h   e   r   m   o   d   e
  1   0   3   2   1   0   4   3   2   1   0

여기서 위아래 숫자 배열의 값 중 더 작은 값으로 answer의 값을 교체한다.

나는 무조건 앞에서부터 조건을 나눠가며 풀어야 한다고 생각했는데, 아예 앞에서부터 값을 쭉 더해준 뒤에 뒤에서부터 다시 인덱스 값을 구하면서 '기존의 것과 비교하여 더 작은 값으로 교체'하여 최소거리를 구한다는 로직이 신박했다.

발상의 전환으로 로직이 아주 단순화될 수 있었던 문제였다.
</pre>
