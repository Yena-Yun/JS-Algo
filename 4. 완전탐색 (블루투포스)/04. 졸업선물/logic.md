# 문제

<pre>
현재 예산으로 최대 몇 명의 학생에게 선물을 사줄 수 있는지 출력
(상품 하나를 50% 할인해서 구매 가능, 배송비는 할인에 미포함)
</pre>

# BEFORE

<pre>
바로 앞의 멘토링 문제에서 너무 큰 고난(?)을 겪어서 그런지 
이번 문제는 비교적 로직을 빨리 세울 수 있었다.
상품을 하나만 할인할 수 있으니 가장 많은 할인을 받으려면 
최대 가격인 선물의 가격을 50% 할인받아야 한다.
그리고 이렇게 해서 지출 금액을 최대한 줄여야 더 많은 학생들에게 선물을 사줄 수 있다.

우선 인수로 들어온 배열을 위에서부터 '세로'로 내려가면서 다음 과정들을 거친다.

1) 배열의 0번째 값(가격)을 미리 선언된 max 값과 비교하여 
max보다 더 크면 해당 값으로 최대 가격 max를 교체하고 해당 배열의 가격을 원래 가격의 50%로 바꾼다.
2) 해당 배열의 가격과 배송비를 합해서 sum에 더해준다. 
cnt(선물을 사줄 수 있는 학생 수)를 증가시킨 뒤 sum이 예산을 넘지 않으면 다음 배열로 넘어간다.
3) 만약 다음 차례에서 기존의 max보다 큰 가격이 나오면, 
기존의 max값의 50%를 다시 sum에 더해준 뒤 새로운 최대가격으로 max를 교체해주고 
다시 가격과 배송비를 합할 때 새로운 최대 가격 50%만큼의 값과 해당 배열의 배송비를 더해서 sum에 누적한다.
4) 위의 과정을 반복하다가 sum이 예산보다 크거나 같아지면 
cnt를 answer와 비교하여 더 크면 cnt로 answer를 교체한다.

로직을 적다 보니 이번 문제는 최대값 변수가 2개 필요함을 알 수 있었다. 
(예산 내 구매 가능한 선물의 최대 가격, 선물을 사줄 수 있는 최대 학생 수 = answer) 
이번에는 BEFORE 작성만으로 대충 로직이 잡힌 것 같아서 세운 로직대로 문제를 풀어보기로 했다.
</pre>

# AFTER

<pre>
코드를 짜다가 마지막 쯤에 도달해서야 알았다. 내 로직으로는 product 배열을 한 사이클만 돌았고, 그 사이클 내에서만 답을 도출했다.
그래서 for-j문을 추가해야겠다는 생각이 들었지만 product 배열 내의 각 배열들을 '1', '2', ... 
이렇게 뭉텅이로 이름 붙였을 때 경우의 수를 (1,2,3), (1,2,4), ..(또는 1,2,4,5가 될 수도 있다) 
이렇게 구해야 하는 문제인데 이 부분을 어떻게 구현해야 할지 막막했다. 
멘토링 문제 때는 학생을 2명씩 짝짓는다는 게 정해져 있었지만 이번 문제는 3명, 4명이 될 수도 있는 부분이 어려웠다.
답 코드를 살짝 보니 초반에 product 배열을 정렬(sort)하고 있었다.
머리가 더 이상 돌아가지 않아 내일 다시 도전해보기로 했다.
---------------------------------------------------------

답 코드를 보니 2가지의 큰 키포인트가 있었다.
1) 처음에 product 배열을 합의 값이 큰 순서대로 정렬한다.
(이렇게 하면 0번째인 요소가 자동으로 '최대값'이 되고 처음에 예산에서 차감하여 바로 남은 돈을 구할 수 있음)
2) '(지출하고) 남은 돈'이란 개념을 사용했다. (이렇게 해서 다음 번 지출이 남은 돈보다 크면 for문을 탈출하고 
아니면 남은 돈을 남은 돈 - 지출로 교체하고 학생 수를 증가시킨 후 j문을 계속 돈다)

그리고 내가 고민했던 (1,2,3), (1,2,4), .. 이 부분 처리는 j문을 돌 때 'j와 i가 다르다'는 조건을 걸어 해결하고 있었다.
풀면서 아무래도 반복문을 한 번 더 돌아야 할 것 같다고 막연히 생각을 했었는데, 
(1,2,3)을 한 번 판단하고 나면 그 다음 (1,2,4) 등으로 넘어가기 전에 사용 가능한 돈과 선물을 줄 수 있는 학생 수를 초기화하는 단계가 있었고, 
그러고 나서 product 배열을 한 번 더 돌고 있었는데 이 부분은 단순히 product 배열 길이까지를 한 번 더 도는 것으로 구현되어 있었다.

cnt가 1로 초기화되는 것은 '선생님이 최소 상품 1개는 살 수 있다'고 문제에서 명시했기 때문이다.
</pre>
