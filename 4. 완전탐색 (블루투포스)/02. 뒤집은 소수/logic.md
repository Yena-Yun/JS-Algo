# 문제

<pre>
각 자연수를 뒤집은 후 그 뒤집은 수가 소수이면 그 소수를 출력 
(첫 자리부터의 연속된 0은 무시)
</pre>

# BEFORE

<pre>
이 문제의 가장 중요한 부분은 '소수'인지 여부를 판별하는 로직이다.
소수인지 판별하는 로직이 조금 복잡했던 것 같아서 isPrime이라는 함수로 빼고, 함수의 return값이 true이면 소수로 간주하여 다음 로직을 진행하기로 했다.

소수인지 여부를 확인하는 로직을 떠올려보면
소수는 1을 제외하고, 1과 자기 자신만으로 나누어 떨어지는, 1보다 큰 양의 정수이다.
(즉, 1과 음수는 소수가 아니다.)
모든 자연수는 소수들의 곱으로 표현된다.
n이 소수가 되려면 2보다 크거나 같아야 하며, n보다 작은 자연수로 나누어 떨어지면 안된다.

소수를 판별하는 방법은 총 3가지이다.

1. 반복문만 사용하기
2. 제곱근 Math.sqrt 사용
3. 에라토스테네스의 체

여기서 코드가 명확한 것은 1번과 2번이다. 

isPrime을 호출할 때의 인수는 각 자연수를 뒤집은 숫자 값이다.
따라서 solution 함수 내부의 첫 번째 로직은 각 자연수를 뒤집어 isPrime 안에 넣는 것이다.
그리고 isPrime 내에서 소수인지 판별한 뒤
solution 내에서 isPrime의 return 값이 true로 판명된 경우만 answer에 그 뒤집은 값을 그대로 넣는다.
뒤집었을 때 소수인 값은 여러 개가 될 수 있으므로 answer는 빈 배열로 초기화한다.
</pre>

# AFTER

<pre>
풀고 나서 답 코드를 보니 isPrime 함수에 Math.sqrt가 보였다.
그리고 내가 만든 isPrime 로직에는 허점이 많아서 인수로 들어온 arr에 다른 특정 값들이 포함되면 사용할 수 없는 메서드였다. ㅠㅠ
예전에 소수를 구하는 로직에서 sqrt가 포함되어 있었다는 사실이 떠올랐지만
왜 제곱근을 써야 하는지가 말로 설명이 잘 안 나왔다.
소수에 대한 개념과 구하는 로직을 명확히 이해하기 위해
이틀에 걸쳐서 소수의 개념과 로직에 대해 다시 공부하고 velog에 정리했다.
(정리한 링크: https://velog.io/@yena1025/%EC%86%8C%EC%88%98Prime-number)

--------------------------------------------------------------------

답 코드의 while문 + %, / 연산자 활용 부분은 도저히 나와 맞는 풀이라 생각이 안 되어서 
뽑은 숫자를 뒤집는 부분은 내장 메서드를 열심히 뭉쳤다. (코드 한 줄에 메서드 5개 쓰기..)
뒤집은 숫자를 isPrime 메서드에 넣어서 소수인지 여부를 판별했는데
이 부분은 내가 새로 공부한 소수의 로직보다 더 간단했다.
왜 2부터 시작하고 제곱근까지만 판별하는지는 정리하면서 완벽히 이해했고,
그 안의 로직은 그저 들어온 숫자가 제곱근까지의 i 중 어느 하나로라도 나눠지는지 여부를 판별하면 되었다. (하나라도 나누어떨어지면 소수가 아닌 '배수'이므로 false 리턴)

</pre>
