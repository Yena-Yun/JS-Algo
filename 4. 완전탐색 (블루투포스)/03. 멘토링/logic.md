# 문제

<pre> 
멘토가 되는 학생은 M번의 수학테스트에서 모두 멘티가 되는 학생보다 등수가 앞서야 한다.
M번의 수학성적이 주어지면 멘토와 멘티로 짝이 만들어지는 경우의 수 출력
</pre>

# BEFORE

<pre>
주어진 배열 인수로 분석해보면, 학생 수는 총 4명이고 시험은 총 3번 본다.
배열 안에 배열이 있으므로 2차원 배열로 풀어야 하니 for-i와 for-j 반복문을 중첩하여 돌린다.
먼저 i번째 배열(arr 배열의 1번째 배열)을 j로 돈다. 
이때 j 인덱스 + 1 값(1, 2, 3, 4)는 학생들의 등수이고, 
j번째의 '값'(3, 4, 1, 2)은 상대적으로 비교 가능한 숫자 값이 아니라 
학생들 각각을 가리키는 '고유한 이름'처럼 기능한다.
그래서 이 문제에서는 i번째 배열의 값들을 비교하는 건 의미가 없고 
각 값의 '인덱스'(= 등수)를 활용해야 한다.

우선 테스트를 1번만 돌았다고 가정했을 때 
멘토/멘티가 될 수 있는 경우의 수는
(3, 4), (3, 1), (3, 2), (4, 1), (4, 2), (1, 2) 이다.

손노동으로 경우의 수를 구하고 보니, 전체 가능한 경우의 수는 총 배열의 길이 - 1 값의 팩토리얼이라는 생각이 들었다.
위에서 총 경우의 수 6이 나온 이유는 i번째 배열의 길이(4) - 1, 즉 3의 factorial 값이었다. (!3)
이렇게 factorial로 우선 가능한 모든 경우의 수를 구하되, 
거기서 '조건'에 맞지 않을 때마다 경우의 수를 걸러내면 최종 답이 나올 것 같았다.

그런데 이 '조건'을 구하는 데서 막혔다.. ㅎㅎ
각 고유한 학생들의 등수를 매번 구해서 매번 각각을 어떻게 비교해서 경우의 수를 줄여나갈지가 도무지 떠오르지 않는다..
</pre>

# AFTER

<pre>
코드를 짜기 위한 감이 아예 안 잡혀서, 
답 코드를 2줄씩 봐 가면서 코드를 분석해보았다.

1) 먼저 답 코드의 첫 2줄을 살짝 보니 문제에서 주어진 M과 N 변수를 먼저 코드로 정의하고 있었다. 
(문제에서 N은 학생들의 수이고, M은 테스트 횟수)
2) 그 다음 2줄에서는 둘 다 n까지 도는 for문 2개가 등장했다. 
두 for문 모두 0이 아닌 1부터 시작하고 학생 수'까지' 돌고 있었다.
즉 보통의 인덱스로 구하면 나타나는 0, 1, 2, 3이 아닌
1, 2, 3, 4 배열을 쓰려고 하고 있었다.
그리고 1-2, 1-3, 1-4, 2-1, 2-2, ... 이런 식으로 차례로 짝짓기 위해 for문 2개를 쓴 듯 하다.
3) 두 for문의 안쪽에서 cnt를 0으로 선언했다.
아래 answer 출력 줄을 보니 cnt는 어느 한 명의 등수가 바뀌었을 때 cnt를 올려 answer를 증가시킬 flag 역할이었다.
4) cnt 바로 아래에 선언된 for-k문은 m(테스트의 횟수)만큼 돌면서 안에 0으로 초기화한 pi, pj라는 변수를 선언하고 그 아래에 또 for-s문을 선언했다. (총 4중 for문..) 
5) for-s문은 학생 수(n)만큼 돌면서 다음 로직을 실행했다. 
근데 '매개변수로 들어온 test 배열의 [k][s]번째 값이 i와 똑같으면 pi에 s를 할당한다'(??)
이 부분이 잘 이해가 안 되었다.

우선 이 문제에서 주어진 값으로는 k는 0, 1, 2이고 s는 0, 1, 2, 3이다.
앞에서의 for-i, for-j와 달리 k와 s 둘 다 0부터 시작한 이유와 
if(test[k][s]===i) pi=s 이 부분이 아무리 고민해도 이해가 되지 않아서 강의를 보았다.

-----------------------------------------------------------------

[ 강의를 들은 이후 다시 분석 ]
강의를 듣고 나서야 코드를 제대로 이해할 수 있었다.
우선 이 문제는 브루트포스(완전 탐색)의 대표적인 문제여서 
경우의 수를 하나하나 다 따져봐야 했다.

우선 강의를 들으며 크게 캐치했던 부분은, 
매개변수로 들어온 배열 test 하나를 가지고
이중 for문을 2번 돈다는 것이었다. (i,j 이중 for문 / k,s 이중 for문)

첫 이중 for문인 i-j 이중 for문에서는 멘토-멘티 매칭이 가능한 모든 경우의 수를 만든다.
이때 인덱스 i, j 자체를 학생의 번호로 사용하므로 1,2,3,4가 되어야 하고,
이를 위해 i와 j 모두 '1'부터 시작하여 범위를 '학생의 수(n)'까지 돌게 된다.

여기서 문제의 의미상 (1, 1)나 (2, 2) 등은 혼자서 멘토/멘티를 다 한다는 뜻이어서 
문제에서 요구하는 경우의 수가 아니지만, 안쪽의 두 번째 이중 for문을 통해 
오답인 부분이 다 걸러질 것이기 때문에 그냥 진행한다고 한다.

이렇게 (1,2,3,4)와 (1,2,3,4)가 모두 서로 매칭이 되는 경우를 구하면
학생들의 짝지어질 수 있는 모든 경우의 수는 총 16가지가 된다.
(i, j의 인덱스는 각각 짝지어진 학생들을 가리키는 숫자 - 예: (3, 1)는 3번 학생과 1번 학생)

이미지로 생각하자면 test 배열의 첫 번째 줄에서 3번 학생과 1번 학생 칸에 하이라이트가 켜진 것이다.
그리고 이 하이라이트가 '세로'로 한 층씩 내려오면서
각 경우에 두 학생의 등수를 따져 앞의 학생의 등수가 뒤의 학생보다 모두 앞설 경우에만 답인 경우의 수가 추가된다.

좀 더 상세히 설명하면 i, j를 통해 얻은 학생의 짝을 가지고 
이중 for문(k, s)을 돌면서 두 학생의 등수를 구한다.
이때 등수는 s와 동일한데, s를 0부터 시작하면 '0등'부터 '3등'까지라는 의미가 되지만
s를 가지고는 나중에 어느 쪽이 더 작은지(등수가 더 앞서는지) '비교'만 하기 때문에 
굳이 1을 더해서 1등, 2등, 3등 식으로 만들지 않아도 되므로 연산 횟수를 줄이고자 그냥 0부터 시작한다.

k-for문을 시작하기 전에 
'각 시험마다 앞쪽 학생이 뒤쪽 학생보다 등수가 앞설 경우'에 대한 flag인 cnt를 선언하고,
k-for문 내부에서는 각 학생의 등수인 pi, pj를 선언하고 0으로 초기화한다.
(이때 cnt, pi, pj를 전역에서 선언하지 않고 반복문 안에서 0으로 초기화하는 이유는 
해당 반복문을 다시 돌 때 자동으로 0으로 초기화되는 효과가 있기 때문이다)

이때 k-for문은 i, j에서 뽑은 학생 한 쌍을 test 배열에서 '세로'로 내려가면서
각 시험 차수마다 s-for문을 돌리기 위한 용도이다.

s-for문의 역할은 i, j로 뽑힌 각 학생들이 k-s for문으로 뽑은 각각의 값과 일치할 경우에 
각 학생의 등수(s)를 pi, pj에 넣어주는 것이다.

s-for문이 끝나면 앞 학생의 등수(pi)가 뒤 학생의 등수(pj) 앞설 때(더 작을 때)만,
즉 하나의 시험에서 한 학생이 다른 학생을 앞섰을 때 cnt를 1 증가시킨다.

이 cnt가 k-for문 이후(= 모든 시험을 다 치렀을 때)
(단 한번의 예외 없이 모두 한 쪽이 다른 한쪽을 앞서서) 시험의 횟수와 cnt 값이 동일하다면,
한 쪽이 다른 학생의 멘토가 될 수 있는 경우에 해당하므로 최종 answer에 1을 추가한다.

-------------------------------------------------------------------

머리로 대충 이해한 거랑 실제로 로직을 다른 사람에게 설명하듯 적어보는 것은
또 다른 문제였고 문제를 더 정확하게 이해할 수 있는 방법이었던 것 같다.
브루트포스가 알고리즘 개념 자체는 쉬웠는데(무조건 다 구하기) 
이걸 코드로 구현하려니 이렇게 힘들구나 싶었다. 빨리 스택/큐를 하고 싶다..
</pre>
