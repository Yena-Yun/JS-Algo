# 문제

<pre> 
멘토가 되는 학생은 M번의 수학테스트에서 모두 멘티가 되는 학생보다 등수가 앞서야 한다.
M번의 수학성적이 주어지면 멘토와 멘티로 짝이 만들어지는 경우의 수 출력
</pre>

# BEFORE

<pre>
주어진 배열 인수로 분석해보면, 학생 수는 총 4명이고 시험은 총 3번 본다.
배열 안에 배열이 있으므로 2차원 배열로 풀어야 하니 for-i와 for-j 반복문을 중첩하여 돌린다.
먼저 i번째 배열(arr 배열의 1번째 배열)을 j로 돈다. 
이때 j 인덱스 + 1 값(1, 2, 3, 4)는 학생들의 등수이고, 
j번째의 '값'(3, 4, 1, 2)은 상대적으로 비교 가능한 숫자 값이 아니라 
학생들 각각을 가리키는 '고유한 이름'처럼 기능한다.
그래서 이 문제에서는 i번째 배열의 값들을 비교하는 건 의미가 없고 
각 값의 '인덱스'(= 등수)를 활용해야 한다.

우선 테스트를 1번만 돌았다고 가정했을 때 
멘토/멘티가 될 수 있는 경우의 수는
(3, 4), (3, 1), (3, 2), (4, 1), (4, 2), (1, 2) 이다.

손노동으로 경우의 수를 구하고 보니, 전체 가능한 경우의 수는 총 배열의 길이 - 1 값의 팩토리얼이라는 생각이 들었다.
위에서 총 경우의 수 6이 나온 이유는 i번째 배열의 길이(4) - 1, 즉 3의 factorial 값이었다. (!3)
이렇게 factorial로 우선 가능한 모든 경우의 수를 구하되, 
거기서 '조건'에 맞지 않을 때마다 경우의 수를 걸러내면 최종 답이 나올 것 같았다.

그런데 이 '조건'을 구하는 데서 막혔다.. ㅎㅎ
각 고유한 학생들의 등수를 매번 구해서 매번 각각을 어떻게 비교해서 경우의 수를 줄여나갈지가 도무지 떠오르지 않는다..
</pre>

# AFTER

<pre>
코드를 짜기 위한 감이 아예 안 잡혀서, 
답 코드를 2줄씩 봐 가면서 코드를 분석해보았다.

1) 먼저 답 코드의 첫 2줄을 살짝 보니 문제에서 주어진 M과 N 변수를 먼저 코드로 정의하고 있었다. (문제에서 N은 학생들의 수이고, M은 테스트 횟수)
2) 그 다음 2줄에서는 둘 다 n까지 도는 for문 2개가 등장했다. 
두 for문 모두 0이 아닌 1부터 시작하고 학생 수'까지' 돌고 있었다.
즉 보통의 인덱스로 구하면 나타나는 0, 1, 2, 3이 아닌
1, 2, 3, 4 배열을 쓰려고 하고 있었다.
그리고 1-2, 1-3, 1-4, 2-1, 2-2, ... 이런 식으로 차례로 짝짓기 위해 for문 2개를 쓴 듯 하다.
3) 두 for문의 안쪽에서 cnt를 0으로 선언했다.
아래 answer 출력 줄을 보니 cnt는 어느 한 명의 등수가 바뀌었을 때 cnt를 올려 answer를 증가시킬 flag 역할이었다.
4) cnt 바로 아래에 선언된 for-k문은 m(테스트의 횟수)만큼 돌면서 안에 0으로 초기화한 pi, pj라는 변수를 선언하고 그 아래에 또 for-s문을 선언했다. (총 4중 for문..) 
5) for-s문은 학생 수(n)만큼 돌면서 다음 로직을 실행했다. '매개변수로 들어온 test 배열의 [k][s]번째 값이 i와 똑같으면 pi에 s를 할당한다' (??)

우선 이 문제에서 주어진 값으로는 k는 0, 1, 2이고 s는 0, 1, 2, 3이다.
앞에서의 for-i, for-j와 달리 k와 s 둘 다 0부터 시작한 이유와 
if(test[k][s]===i) pi=s 이 부분이 도저히 이해가 되지 않아 강의를 다시 보았다.

</pre>
