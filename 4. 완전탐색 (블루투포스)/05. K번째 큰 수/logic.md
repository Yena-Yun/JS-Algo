# 문제

<pre>
1부터 100사이의 자연수가 적힌 N장의 카드에서 3장을 뽑아 
각 카드에 적힌 수를 합한 값을 기록한 뒤, 기록한 값 중 K번째로 큰 수를 출력
(기록한 값 중에서 같은 숫자가 여러 개 있을 수 있음)
</pre>

# BEFORE

<pre>
[풀이 순서]
1) N장으로 들어온 card 배열에서 3장을 뽑아 합을 구하는 모든 경우의 수를 구한다.
2) 각 경우의 3장의 카드의 합을 sum 배열에 차례로 추가한다.
3) sum 배열에 총합 중 같은 숫자가 있을 수 있으므로 Set 자료구조를 통해 중복되는 숫자를 제거한다.
4) 중복 숫자를 제거한 sum 배열(tmp)에서 K번째로 큰 수를 찾기 위해 
tmp 배열을 내림차순으로 정렬한 뒤 K번째의 값을 출력한다.
</pre>

# AFTER

<pre>
이번 문제는 답을 보지 않고 혼자 풀어낼 수 있었다. 심지어 로직 작성과 문제 풀이를 합쳐 20분 정도밖에 걸리지 않았다. 그래서 답이 나왔을 때 '으잉?'하는 생각과 답을 구했다는 생각에 너무 기쁜 마음, 
그리고 한편으로는 '이렇게 쉽게 풀릴 리 없다'는 의심이 마음 한 구석에 자리잡았다. 
그동안 풀어온 완전탐색 문제들이 너무 어려워서 문제를 풀어놓고도 나를 의심하는 상황이었다. 
(심지어 맨 마지막 문제라 제일 어려울 거라는 편견도 있었고..) 근데 암튼 풀었다. ㅎㅎ 

답 코드를 확인해보니 다행히 내가 짠 코드와 로직상에서 큰 차이는 없었다. 
다만 표현에서 조금 다른 부분들이 몇 가지 있어서 정리하고 코드에 추가했다.
1) 처음부터 Set 자료구조인 tmp를 사용하고 Set의 메서드인 add를 써서 tmp에 카드의 합들을 추가했다. 
(이렇게 하면 sum 배열을 따로 생성할 필요가 없다)
2) 마지막 부분에 Array.from을 사용하여 Set 구조인 tmp를 배열로 바꾸고 바로 sort를 써서 정렬했다.
3) 깨알 발견 - j와 k for문의 범위를 나는 0부터 시작했는데 답 코드에선 각각 이전에 돈 변수의 + 1에서 시작했다. 
생각해보니 매번 3장을 뽑을 때 한번 뽑은 카드는 또 뽑지 않기 때문이었다. 답에서의 차이는 없었지만
연산을 좀 덜한다는 최적화 관련한 부분, 그리고 이렇게 해야 가장 k문 안쪽에 썼던 if문을 안 쓸 수 있었다. (써보고 나니 조금이 아니다..)

Set의 메서드 add, 배열을 형성해주는 Array.from, 그리고 반복문의 도는 범위 이 세 가지를 가져갈 수 있었던 문제였다. 
</pre>
