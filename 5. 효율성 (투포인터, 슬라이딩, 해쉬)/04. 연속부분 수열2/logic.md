# 문제

<pre>
N개의 수로 이루어진 수열에서 연속부분수열의 합이 특정숫자 M 이하가 되는 경우의 수 구하기
</pre>

# BEFORE

<pre>
[ 테스트 케이스 분석 내용 ]
* 중복값 허용 
* 1개씩 먼저 잡고, 그 다음은 2개씩, 그 다음은 3개씩,... (잡는 갯수가 하나씩 늘어난다)

우선 바로 이전 문제처럼 lt, rt를 잡고
lt는 0으로 미리 초기화, rt는 for문 내에서 초기화
그리고 sum과 while문, if문을 사용하여 문제를 풀 예정이다.

이번 문제는 매 for문을 돌 때마다 뽑을 숫자 갯수(1개, 2개, 3개, ..)를 정해서 풀면 편할 것 같았다. 
그래서 부분수열의 갯수가 고정되어 있는 '슬라이딩 윈도우' 개념을 쓰기로 했다.
슬라이딩 윈도우는 뽑는 갯수가 정해져 있고 창문을 밀어 이동하듯이 고정된 길이의 수열을 이동시키며 연산에 활용하는 방식이다.

종이에 직접 lt와 rt를 써 가며 규칙을 찾아보니 다음과 같았다.

arr: [1, 3, 1, 2, 3]
n = arr.length = 5
lt = 0; rt = 0; sum = 0

[lt와 rt가 각 차례마다 도는 범위]
                lt        rt              sum
[1개씩 뽑기]   0~(n-1)   0~(n-1)   arr[lt++] + arr[rt++] 
[2개씩 뽑기]   0~(n-2)   1~(n-1)   arr[lt++] + arr[rt++]
[3개씩 뽑기]   0~(n-3)   2~(n-1)   arr[lt++] + arr[rt++]
[4개씩 뽑기]   0~(n-4)   3~(n-1)   arr[lt++] + arr[rt++]
[5개씩 뽑기]   0~(n-5)   4~(n-1)   arr[lt++] + arr[rt++]

* lt는 뒷 부분((n-1)부분)이 1부터 n(5)까지 증가하고, rt는 앞 부분이 0부터 n-1(4)까지 증가
* 뽑는 부분수열의 갯수는 배열의 길이 n까지만 가능 (= 배열의 길이가 5이면 한 번에 5개를 초과하여 뽑을 수 없음)
* sum에서 1개만 뽑을 때의 예외처리를 위해 'lt가 rt와 같지 않을 때만' arr[lt]를 더해준다고 조건 걸기
</pre>

# AFTER

<pre>
BEFORE의 로직으로 규칙은 찾았지만 코드를 짜기가 쉽지 않아서 답 코드를 참고했다.

[ 풀이 순서 ]
1. lt와 sum, answer를 0으로 초기화한다.
2. rt를 for문으로 0번째부터 arr의 길이 바로 앞까지 돌리면서 sum에 arr의 rt번째 값을 더할 때마다 answer에 (rt-lt+1)값(= 합이 m 이하인 경우의 수)을 추가한다.
3. 이때 만약 sum이 m을 초과하면 sum이 m보다 작거나 같을 때까지 계속해서 sum에서 arr의 lt번째의 값을 빼 주고 lt를 1 증가시킨다. 
4. 만약 while문을 통해 sum이 m보다 다시 작거나 같게 되면 이때도 answer에 경우의 수를 추가하는 작업을 진행한다.

----------------------------------------------------------
슬라이딩 윈도우의 개념 공부를 할 때 고정된 수열을 한 칸씩 이동시키는 방법이 맨 앞(lt)의 값을 빼고 맨 뒤(rt)의 값을 하나씩 더하는 거였는데 코드로는 이렇게 구현한다는 걸 알게 되었다.

답 코드대로 lt와 rt값을 종이에 쓰면서 따라가보니 예상과 달리 문제에서 예시로 보여주었던 수열의 순서대로가 아니었고, answer에 희한한 방식으로 경우의 수를 추가하며 for문을 돌리고 있었다. 
rt - lt + 1이 왜째서 경우의 수가 되는 거지..?
또 이전 문제들과 달리, sum을 0으로 초기화시키는 부분이 따로 없고 계속 sum에 누적해서 추가해주었다.
그리고 그 누적값이 특정 값 m의 이하인지를 계속 판별했다. (초과할 때는 앞부분을 빼주고
lt를 앞으로 한 칸 당겨서 '창문'의 크기를 줄였다)

각 변수들을 콘솔을 찍어가며 다시 확인해보니 좀 더 이해가 되는 느낌이다.
어제 answer가 이상해보였던 이유는 경우의 수인데 누적을 안 해줘서 였다.
이틀 정도 고민했으니 이 문제는 이 정도로 하고 패스 😑
</pre>
