# 문제

<pre>
N개의 원소로 구성된 자연수 집합을 두 개의 부분집합으로 나누었을 때 
두 부분집합의 원소의 합이 서로 같은 경우가 존재하면 “YES"를 출력하고, 그렇지 않으면 ”NO"를 출력
(둘로 나뉘는 두 부분집합은 서로소 집합이며, 두 부분집합을 합하면 입력으로 주어진 원래의 집합이 됨)
</pre>

# BEFORE

<pre>
문제를 풀기 위해 먼저 서로소의 개념에 대해 찾아보았다.

서로소는 1 이외의 공약수를 갖지 않는 두 자연수이다.
예를 들어 2와 5은 공약수가 1,2니까 서로소가 아니지만 5와 7은 공약수가 1뿐이니까 서로소이다.

문제에서 둘로 나뉘는 두 부분집합은 서로소 집합이라고 했는데
예시는 1번째 집합은 서로소였지만 2번째 집합은 아니었다. (6, 10 => 공약수 1, 2)
그래서 서로소인 집합을 하나만 구하면 나머지 합이 서로 맞는지 확인하는
2번째 집합은 서로소 여부가 상관 없다고 간주하기로 했다.

우선 문제를 풀려면 
1. 먼저 서로소인 집합을 구하고
2. 1번째 구한 집합들을 제외한 나머지 요소들의 집합을 구한 다음 
3. 각자의 합이 서로 동일한 경우가 있는지를 확인하면 된다.

반환할 answer를 처음에 'NO'라고 초기화해놓고 위의 3번에 해당하는 경우가 1번이라도 있으면 'YES'를 출력하면 된다.

서로 합이 같은지 여부를 집합으로 알아내는 부분이 좀 어려울 것 같다.
</pre>

# AFTER

<pre>
먼저 서로소인 집합을 어떻게 구해야 하는 지가 고민되었다.
유사한 개념일 것 같았던 소수(prime number)에 대해 찾아보니 1보다 큰 자연수 중 1과 자기 자신만을 약수로 가지는 수였다.
~결국 소수인 자연수의 집합을 구하면 될 것 같아서 제곱근까지만 돌려서 소수인지 여부를 확인하는 isPrime 함수를 선언했다.~

답 코드를 보니 서로소와 소수는 전혀 상관 관계가 없다는 걸 알았다.
소수는 '개별' 숫자 단위이고 서로소는 2개 이상의 숫자의 '공약수'라서 애초에 같이 갈 수 없는 개념이었다.

답 코드의 재귀는 여전히 이해가 어려웠지만 서로 합이 같은지 여부를 구하는 방법은 쉽게 알 수 있었다.
바로 전체 합(total)에서 어느 한쪽을 다 더한 값인 sum을 뺀 값이 sum과 동일한지 여부를 보면 되는 거였다.
또한 flag 변수를 통해 답이 'YES'가 되었을 경우 다음 차례에 return을 시키고 있었다.

L을 index(arr[L])처럼 쓰기도 하고 n(arr.length)으로 쓰기도 하는 걸 볼 수 있었다.
sum과 L 둘 다 문맥상으로 모두 가장 작은 숫자(0)에서 점점 커져야 하기 때문에
초기값으로 0을 선언했다.
그런데 답 코드에서는 '서로소인지 여부'를 따로 구하는 부분은 보이지 않았다.
아마 그게 들어가면 너무 어려워서인가 0_0 구글에 검색해도 서로소 코드는 잘 안 보여서 답 코드를 기대했는데 조금 아쉬웠다.
</pre>
