# 문제

<pre>
지도 정보가 N*N 격자판에 주어집니다. 
각 격자에는 그 지역의 높이가 쓰여있습니다. 
각 격자판의 숫자 중 자신의 상하좌우 숫자보다 큰 숫자는 봉우리 지역입니다. 
봉우리 지역이 몇 개 있는지 알아내는 프로그램을 작성하세요.

격자의 가장자리는 0으로 초기화 되었다고 가정합니다.
만약 N=5이고 격자판의 숫자가 다음과 같다면, 봉우리의 개수는 10개입니다.

0 0 0 0 0 0 0
0 5 3 7 2 3 0
0 3 7 1 6 1 0
0 7 2 5 3 4 0
0 4 3 6 4 1 0
0 8 7 3 5 2 0
0 0 0 0 0 0 0

▣ 입력설명
첫 줄에 자연수 N이 주어진다.(1<=N<=50) 
두 번째 줄부터 N줄에 걸쳐 각 줄에 N개의 자연수가 주어진다. 
각 자연수는 100을 넘지 않는다. 

▣ 출력설명
봉우리의 개수를 출력하세요.
</pre>

# BEFORE

<pre>
------------ 1일째 --------------
우선 봉우리가 되는 조건은, 한가운데 값을 기준으로 상하좌우 방향의 값들을 비교했을 때
그 어느 값보다도 한가운데의 값이 클 때이다.
위치상으로 제일 가장자리에 있는 숫자들, 즉 0번째와 마지막 배열,
그리고 각 배열의 0번째 index나 가장 마지막 index일 때는
숫자가 없는 자리에 0이 있다고 가정한다.
상하좌우 값을 비교하기 위한 '동서남북' 좌표 변수들도 필요할 것이다.

이중 for문(i, j)으로 돌면서 격자판 내부의 각 요소를 하나씩 잡고,
잡힌 요소에서 동서남북으로 돌면서 각각의 값을 비교해야 하니까
삼중 for문(k)도 필요하다.

풀다가 '격자판 내부가 아닐 때'의 값을 어떻게 처리해야 할지 몰라 
다음 날 다시 풀어보기로 했다.

------------ 2일째 --------------
2일째 문제를 풀면서는 직접 격자판을 손으로 그려봤다.
우선 문제의 격자판을 다 그리고, 칸 안의 숫자 밑에 (0,0), (0,1), ...
이런 식으로 좌표를 다 적은 다음 문제의 격자판에 있는 숫자 하나를 기준으로 잡고
다음과 같은 십자가 모양의 추상화된 격자판을 하나 더 만들었다.

             arr[i-1][j]
arr[i][j-1]   arr[i][j]   arr[i][j+1]
             arr[i+1][j]


이렇게 하고나니 이중 for문 안에서 격자판의 각 요소에 해당하는 동서남북 좌표들을
구해야겠다는 생각이 들었고(각 i, j마다 동서남북의 좌표를 구할 수 있으니까)

매번 변수를 재선언하는 것보다 전역에서 미리 선언해서
자바스크립트에서 메모리 공간을 미리 확보해놓고
이중 for문을 돌 때 재할당을 하는 게 낫겠다는 생각이 들었다. (사소하게 최적화하기..)

만들어진 좌표들을 모아놓는 배열(coord)도 마찬가지로 전역에서 선언하고 for문 안에서 재할당하는 방법을 사용했다.
coord를 만든 이유는, 동서남북 값을 3번째 for문(k)으로 돌리면서 이중 for문으로 뽑은 값과
비교해야 하는 과정에서 동서남북 좌표값이 iterable해야 한다고 생각해서이다.

이중 for문을 돌면서 가장자리 값인지 여부를 판별하기 위해서는 삼항 연산자로 조건을 걸어 각 좌표에 값을 할당했다.

하지만 이 코드로는 답이 계속 10이 아닌 15가 출력되었다..
나머지는 내일 해봐야겠다.

------------ 3일째 --------------
오늘 다시 코드를 보니 봉우리를 판별한 후 coord 배열 초기화를 빼먹었다는 사실을 알았다. 
하지만 그 코드를 추가해도 계속 답이 한 개가 더 추가된 11이 나왔다.
답의 값으로는 실제 답(10)과 1 차이지만 어딘가 로직이 완전히 틀린 부분이 있기 때문에
원하는 답이 안 나오는 것이라는 생각에 오답이 나오는 규칙을 찾아보았다.

우선 봉우리로 잡힌 값들을 콘솔에 찍어서 하나하나 확인해보니
마지막 줄에 들어가면 안 되는 '3'이 하나 더 포함되고 있었다.
다른 건 다 건너뛰면서 왜 이것만 오답으로 포함되는지 알 수가 없었다.

결국 3일 만에 답 코드를 확인했는데 
우선 내가 짠 코드보다 너무 간결해서 1차로 놀랐고,
flag로 봉우리 여부를 판별하는 방법을 쓰고 있어서 2차로 놀랐다. (실은 T/F는 boolean으로 판별하는 게 기본이었는지도..)

좀 더 자세히 코드를 살펴보니 풀이의 큰 특징으로 2가지가 있었다.
첫째, 값 자체가 아닌 index를 위주로 사용했고
둘째, 위에서 말한 것처럼 flag를 사용해서 true인지 여부에 따라 봉우리를 판별하고 있었다.
그리고 여기서 true, false라는 기본 boolean 값을 안 쓰고
1과 0을 boolean으로 활용한 Truthy, Falsy 개념을 활용하고 있었다. (=> 코드 간결화!)
내가 사용한 cnt로 갯수를 추가해서 갯수가 4인지 판별하는 방법보다 훨씬 간결했고 연산 횟수도 더 적은 것 같았다.

index로 푸는 부분에서는, 왜 index만 갖고도 문제가 풀릴 수 있는지 생각해보니
내가 그린 추상화된 격자판에서 arr~이 계속 겹치는 부분이었다는 게 떠올랐다.

추상화의 기본은 '중복을 제거'하는 것이다.
심지어 dx, dy에는 i, j도 없고 -1, 0, 1만 있었다.
내가 2일째에 그렸던 격자판은 추상화가 덜 된 격자판이었던 것이다..

2일째에 그린 추상화 격자판에 중복을 제거하면서 다시 그려봤다.

          [i-1][j]
[i][j-1]   [i][j]   [i][j+1]
          [i+1][j]

우선 arr만 빼고서도 답 코드의 dx, dy 배열이 어디에서 나온 것인가 대략 추측이 되었다.
서로 겹치는 i, j까지 제거하고 나니 다음과 같이 되었다.

         [-1][0]
[0][-1]   [0][0]   [0][1]
         [1][0]

익숙한 css의 margin padding 단축 방향에 따라 위, 우, 아래, 좌 순서로 x, y 좌표를
뽑아보니 dx, dy 배열 모양이 정확히 나왔다. 유레카..! ㅠㅠ

답 코드를 처음 봤을 때는 dx, dy 배열을 보고 물음표밖에 안 떠올랐는데 
이게 드디어 이렇게 이해되는구나 싶어서 기뻤다. (예전에 강의 들은 걸 떠올려보면 d는 direction이었다)

index로 푼 부분을 뜯어보면서 추가로 느낀 것은
인접한 값들의 동서남북만 따지니까 index가 어디이든 상관없이 무조건 index - 1, index + 1 이런 식으로 1을 더하거나 빼서 판단을 해도 된다는 것이다. (행이나 열이 안 바뀌면 그대로 0)

규칙을 쉽게 찾고 간결한 코드를 짜기 위해서의 추상화의 중요성을 
이 문제를 풀면서 많이 느낄 수 있었다.
추상화를 잘 하면 재사용성, 확장성, 가독성 모두를 잡을 수 있다는 생각도 들었다.
</pre>

# AFTER

<pre>
문제를 다시 풀 때는 또 다른 2가지를 답 코드와 다르게 생각했다는 걸 알았다.
첫째, 나는 격자판 내부가 아닌 값(가장자리 바깥의 0)을 이중 for문을 돌 때마다 일일이 제거하려고 생각했는데, 
답 코드는 아예 비교하는 동서남북 값이 격자판 내부의 값일 때만
이중 for문으로 뽑은 값과 비교하는 방식으로 범위를 축소하고 있었다.
둘째, 나는 cnt를 0, 즉 봉우리가 아닌 경우를 초기값으로 두고 for문을 돌리면서 봉우리인 것으로 판별나면 cnt를 증가시키는 방법으로 풀었다.
그런데 답 코드는 반대로 우선은 봉우리라고 가정하고 (flag = 1) 이후 조건에 맞지 않으면 flag를 false(0)으로 만들어 for문 바깥의 answer++ 줄이 실행되지 않도록 했다. 

문제를 풀면서 break 활용하는 방법도 다시 한번 접하게 되었다. 반복문을 탈출하는 키워드로 모던 JS에서 볼 때는 이론적으로만 이해했는데 문제에서 실제 적용하게 되니 좋았다. 

보통은 답 코드를 확인할 일이 있으면 답 코드와 차이나는 부분이 조금밖에 없어서
그 부분을 수정하고 깃허브에 커밋을 했는데 이번 문제는 혼자 풀어보느라고 고생을 많이 해서
내가 짰던 코드도 그대로 남기고 답 코드로 다시 푼 부분도 같이 커밋했다.
시간이 얼마가 걸려도 '문제가 풀렸다'는 느낌은 정말 좋은 것 같다.
</pre>
